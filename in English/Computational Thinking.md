# Computational Thinking: 
Refers to the process involved in expressing solutions in computational steps or algorithms that can be implemented on a computer. (Aho, 2011; Lee, 2016).

## Problem formulation and solving: 

#### Systematic: 
Computational thinking is a systematic process, involving well-defined steps.
#### Efficient: 
Computational thinking seeks to find efficient solutions that use the minimum amount of resources possible.
#### Human and machine: 
Computational thinking should be understandable by both humans and machines.

* It's a generalist skill.

## Based on 4 pillars:

### Decomposition:
Divide a complex problem into simpler subproblems that are easier to solve. For example, to solve a puzzle, you break it down into smaller pieces.

### Pattern recognition: 
Identify patterns or trends within a particular problem or within different problems. This can occur due to similarities or differences between the problems, or by behavioral patterns (for example, the "sardine effect" or "herd mentality").

### Abstraction:
 "You need to take a particularity of a particular scenario and extrapolate it in such a way that it becomes generalizable." Extrapolate the concept of the problem to a more general form. (What is something abstract? It is something that only exists in the idea or concept. In philosophy, abstraction is any representation that does not correspond to any sensory data or concept. It is that which is difficult to understand. In a figurative sense, abstract means distracted, absorbed.)

### Algorithm design:
 Automate the solution of a problem, defining it step by step. An algorithm consists of an input that needs an output, and a set of operations that will be performed to achieve that solution.
Problem -> Set/Sequence of operations -> Solution

## Continuous process

* Define a solution
* Test the solution
* Improve the solution found. To optimize resources, that is, faster and at a lower cost. (The more efficient, the less resource you should use)

### Cycle:

Analysis (define solution) -> Testing -> Refinement -> Analysisâ€¦

### Variation of the pillars/complementary

* Logical reasoning
* Refinement

## Examples of the use of computational thinking:

#### Chemistry: 
Improvement of chemical reactions through the use of algorithms, through the identification of chemicals.

### Engineering:
Aircraft simulations executed via software instead of a wind tunnel, saving resources.

### Biology:
 Modeling and mapping of the human genome.

### Computer science: 
Simulation of high-order problems on supercomputers.

## Competencies that you gain from computational thinking:

### Systematic thinking: 
Computational thinking is a systematic process, involving well-defined steps. This helps you think more organized and efficiently, both in personal and professional life.

### Teamwork: 
Computational thinking emphasizes the importance of collaboration to solve complex problems. This helps you work better with other people, sharing ideas and resources.

### Creativity and design: 
Computational thinking requires creativity to identify patterns and innovative solutions. This helps you think outside the box and find new ways to solve problems.

### Facilitator:
Computational thinking helps you explain complex concepts in a clear and concise way. This can be a valuable skill in a variety of contexts, from teaching to problem-solving.

### Critical thinking: 
Computational thinking requires the use of logical reasoning to evaluate information and make decisions. This helps you think more critically and make informed decisions.

## Here are some examples of how these skills can be applied in real life:

* A student can use computational thinking to break down a large project into smaller, more manageable tasks.

* An employee can use computational thinking to collaborate with colleagues to find a solution to a business problem.

* A designer can use computational thinking to create a product or service that meets the needs of users.

* A teacher can use computational thinking to explain a complex concept in a clear and concise way.

* A decision-maker can use computational thinking to evaluate information and make informed decisions.

## Complementary skills

### Logical reasoning:
Logical reasoning is a structured form of thinking, or reasoning, that allows you to find the conclusion or determine the solution to a problem.
It is a skill that can be developed through practice.

#### Classification:

* Induction: 
Given a phenomenon that I am observing, I will take that particularity, specific scenario, and extrapolate it into the field of ideas and determine laws and theories based on what I saw and experienced. It is widely used in the Experimental Sciences.

* Deduction: 
It occurs inversely to Induction; Given a law and a theory, you will perform a deduction, which will make predictions and explanations. Widely used in the Exact Sciences

* Abduction:
Uses the conclusion to determine the premise. Ex: The grass is wet, so it must have rained.

The first type of logical reasoning, the inductive one, is used in discoveries, the abductive one in diagnoses, and in investigative processes.

## Family Puzzle
A father, mother, and their two children are sitting at a table. The men are named Roberto and Sergio, the women Teresa and Fernanda. It is known that the father is in front of Fernanda and the son to the left, and that the mother is to the right of Sergio.

### Solution:

Sergio is the father, Teresa is the mother, Roberto is the son, and Fernanda is the daughter.

Refinement
* Refinement: Improvement, perfection, polishing, refinement. From a solution, determine improvement and refinement points.

### Action of perfecting:

1. Find an efficient solution.
2. Optimize processes.
3. Simplify lines of code.
4. Define well-defined functions.
1 and 2: Better use of resources.
3 and 4: Improve codes and algorithms.

It is a continuous process present at all stages.

#### Advantages:
* Better understanding
* More efficiency
* Less time
* Less storage

# Pillars

**Decomposition:** *"If you can't solve a problem, then there is an easier problem that you can solve: find it" (George Polya)*. *"If you have a problem that you can't solve, it means there is an easier problem that can be resolved."*

*When faced with a complex problem, we should break it down into smaller, more manageable problems.*

**Strategy:**

1. **Analysis Phase:** The process of breaking down and determining smaller, manageable parts. It involves:
   - Studying and exploring the problem in a way that allows you to decompose it into constituent elements.
   - Conducting a detailed examination for more effective resolution.

2. **Synthesis Phase:** Combining the elements to reconstruct the original problem. Once you have separated the problem into smaller parts, these parts need to be aggregated and recomposed in a way that makes sense. Synthesis is a process of reconstruction, involving bringing distinct elements together into a coherent whole.

**Order of Execution for Smaller Tasks:**

It can vary, either sequentially or in parallel.

- *Sequential:* There is a dependency between tasks, executed in a queue.

- *Parallel:* Tasks can be executed concurrently, occurring at the same time and in parallel.

It's not enough to just apply it. Develop decomposition "by yourself."

Different ways to decompose the same problem.

**How to Decompose?**

Understand the problem. Put the main problem in the background and focus on the components, identifying dependent characteristics.

- Identify or collect data -> Aggregate the data -> Functionalities

**Examples:**

- Cooking:
  - Identify the ingredients.
  - Determine the steps (sequential or parallel).
  - Execute each step.
  - Aggregate the ingredients to finish (recompose coherently).

- Bicycle Operation:
  - Identify the components.
  - Role of each component.
  - Interdependence of the parts.
  - All of this together results in the functioning of the system/bicycle.

- Creating an Application:
  - Purpose.
  - Interface.
  - Functionalities.
  - Prerequisites.
  - All of this, when combined, results in the definition of components and stages.

- Article:
  - What will be covered?
  - Structure.
  - Content of each topic.
  - Connection texts.
  - Definition of components and stages.
