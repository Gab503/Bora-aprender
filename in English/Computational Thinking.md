# Computational Thinking: 
Refers to the process involved in expressing solutions in computational steps or algorithms that can be implemented on a computer. (Aho, 2011; Lee, 2016).

## Problem formulation and solving: 

#### Systematic: 
Computational thinking is a systematic process, involving well-defined steps.
#### Efficient: 
Computational thinking seeks to find efficient solutions that use the minimum amount of resources possible.
#### Human and machine: 
Computational thinking should be understandable by both humans and machines.

* It's a generalist skill.

## Based on 4 pillars:

### Decomposition:
Divide a complex problem into simpler subproblems that are easier to solve. For example, to solve a puzzle, you break it down into smaller pieces.

### Pattern recognition: 
Identify patterns or trends within a particular problem or within different problems. This can occur due to similarities or differences between the problems, or by behavioral patterns (for example, the "sardine effect" or "herd mentality").

### Abstraction:
 "You need to take a particularity of a particular scenario and extrapolate it in such a way that it becomes generalizable." Extrapolate the concept of the problem to a more general form. (What is something abstract? It is something that only exists in the idea or concept. In philosophy, abstraction is any representation that does not correspond to any sensory data or concept. It is that which is difficult to understand. In a figurative sense, abstract means distracted, absorbed.)

### Algorithm design:
 Automate the solution of a problem, defining it step by step. An algorithm consists of an input that needs an output, and a set of operations that will be performed to achieve that solution.
Problem -> Set/Sequence of operations -> Solution

## Continuous process

* Define a solution
* Test the solution
* Improve the solution found. To optimize resources, that is, faster and at a lower cost. (The more efficient, the less resource you should use)

### Cycle:

Analysis (define solution) -> Testing -> Refinement -> Analysisâ€¦

### Variation of the pillars/complementary

* Logical reasoning
* Refinement

## Examples of the use of computational thinking:

#### Chemistry: 
Improvement of chemical reactions through the use of algorithms, through the identification of chemicals.

### Engineering:
Aircraft simulations executed via software instead of a wind tunnel, saving resources.

### Biology:
 Modeling and mapping of the human genome.

### Computer science: 
Simulation of high-order problems on supercomputers.

## Competencies that you gain from computational thinking:

### Systematic thinking: 
Computational thinking is a systematic process, involving well-defined steps. This helps you think more organized and efficiently, both in personal and professional life.

### Teamwork: 
Computational thinking emphasizes the importance of collaboration to solve complex problems. This helps you work better with other people, sharing ideas and resources.

### Creativity and design: 
Computational thinking requires creativity to identify patterns and innovative solutions. This helps you think outside the box and find new ways to solve problems.

### Facilitator:
Computational thinking helps you explain complex concepts in a clear and concise way. This can be a valuable skill in a variety of contexts, from teaching to problem-solving.

### Critical thinking: 
Computational thinking requires the use of logical reasoning to evaluate information and make decisions. This helps you think more critically and make informed decisions.

## Here are some examples of how these skills can be applied in real life:

* A student can use computational thinking to break down a large project into smaller, more manageable tasks.

* An employee can use computational thinking to collaborate with colleagues to find a solution to a business problem.

* A designer can use computational thinking to create a product or service that meets the needs of users.

* A teacher can use computational thinking to explain a complex concept in a clear and concise way.

* A decision-maker can use computational thinking to evaluate information and make informed decisions.

## Complementary skills

### Logical reasoning:
Logical reasoning is a structured form of thinking, or reasoning, that allows you to find the conclusion or determine the solution to a problem.
It is a skill that can be developed through practice.

#### Classification:

* Induction: 
Given a phenomenon that I am observing, I will take that particularity, specific scenario, and extrapolate it into the field of ideas and determine laws and theories based on what I saw and experienced. It is widely used in the Experimental Sciences.

* Deduction: 
It occurs inversely to Induction; Given a law and a theory, you will perform a deduction, which will make predictions and explanations. Widely used in the Exact Sciences

* Abduction:
Uses the conclusion to determine the premise. Ex: The grass is wet, so it must have rained.

The first type of logical reasoning, the inductive one, is used in discoveries, the abductive one in diagnoses, and in investigative processes.

## Family Puzzle
A father, mother, and their two children are sitting at a table. The men are named Roberto and Sergio, the women Teresa and Fernanda. It is known that the father is in front of Fernanda and the son to the left, and that the mother is to the right of Sergio.

### Solution:

Sergio is the father, Teresa is the mother, Roberto is the son, and Fernanda is the daughter.

Refinement
* Refinement: Improvement, perfection, polishing, refinement. From a solution, determine improvement and refinement points.

### Action of perfecting:

1. Find an efficient solution.
2. Optimize processes.
3. Simplify lines of code.
4. Define well-defined functions.
1 and 2: Better use of resources.
3 and 4: Improve codes and algorithms.

It is a continuous process present at all stages.

#### Advantages:
* Better understanding
* More efficiency
* Less time
* Less storage

# Pillars

**Decomposition:** *"If you can't solve a problem, then there is an easier problem that you can solve: find it" (George Polya)*. *"If you have a problem that you can't solve, it means there is an easier problem that can be resolved."*

*When faced with a complex problem, we should break it down into smaller, more manageable problems.*

**Strategy:**

1. **Analysis Phase:** The process of breaking down and determining smaller, manageable parts. It involves:
   - Studying and exploring the problem in a way that allows you to decompose it into constituent elements.
   - Conducting a detailed examination for more effective resolution.

2. **Synthesis Phase:** Combining the elements to reconstruct the original problem. Once you have separated the problem into smaller parts, these parts need to be aggregated and recomposed in a way that makes sense. Synthesis is a process of reconstruction, involving bringing distinct elements together into a coherent whole.

**Order of Execution for Smaller Tasks:**

It can vary, either sequentially or in parallel.

- *Sequential:* There is a dependency between tasks, executed in a queue.

- *Parallel:* Tasks can be executed concurrently, occurring at the same time and in parallel.

It's not enough to just apply it. Develop decomposition "by yourself."

Different ways to decompose the same problem.

**How to Decompose?**

Understand the problem. Put the main problem in the background and focus on the components, identifying dependent characteristics.

- Identify or collect data -> Aggregate the data -> Functionalities

**Examples:**

- Cooking:
  - Identify the ingredients.
  - Determine the steps (sequential or parallel).
  - Execute each step.
  - Aggregate the ingredients to finish (recompose coherently).

- Bicycle Operation:
  - Identify the components.
  - Role of each component.
  - Interdependence of the parts.
  - All of this together results in the functioning of the system/bicycle.

- Creating an Application:
  - Purpose.
  - Interface.
  - Functionalities.
  - Prerequisites.
  - All of this, when combined, results in the definition of components and stages.

- Article:
  - What will be covered?
  - Structure.
  - Content of each topic.
  - Connection texts.
  - Definition of components and stages.


# Pattern Recognition

- **Base Model.**
- **Invariant Structure.**
- **Repetition.**

We can identify similarities and differences in a situation or problem.

**Example:** Social media photos.

**Why identify patterns?** It is a way to generalize, with the goal of solving different problems.

**Classifying objects based on Classes and Categories we know**, varying according to the domain and the type of media/object.

**How does the computer recognize patterns?** How does a human do it?

*By humans:*
- Degree of similarity.
- Known groups vs. unknown object. For example, an unknown fruit; I don't know what kind of fruit it is, but I know it's a fruit, it has seeds, peel, color, etc. Patterns that help me identify it as a fruit.
- Comparison.

*By the computer: How can we simulate this behavior on the computer?*
- Attribute representation (providing data to the computer so it understands what a particular object means).
- Learning - concept associated with the object.
- Storing data (so the computer can access it and make decisions about categorizing a particular object).
- Establishing decision rules.

**Summary:** Pattern recognition is part of an approach in which you extract the features of a problem and classify this data using different methods, applying them in different contexts.

**Applications:**
- Data classification.
- Recognition.
- Speech recognition.
- Scene analysis.
- Document classification.

It is widely used in Machine Learning, Neural Networks, Artificial Intelligence, and Data Science.

# Abstraction/Generalization

- **Abstraction** consists of observing one or more elements, evaluating their characteristics and properties, and separating them.
- **Abstraction** is an intellectual process of isolating an object from reality.
- **Generalization** is to become general, broader, an extension/extension (taking from the concrete/solid and placing it "in the world of ideas").
- **Generalization**, in logic, is the intellectual operation that consists of bringing together in a general class a set of similar beings or phenomena.

**How to classify data?**
- Characteristics
- Essential points. For example, a table can have various shapes (round, square, rectangular), but they have an essence that makes them tables.
- Generalize vs. Detail

**Data representation:**
- For example, student data:
  - Essential points: Name, registration number, address, campus, course, phone, email...
  - Details: Work, children, hobbies, shoe size...

**Concepts based on abstractions:**
- Algorithms
  - Merge Sort
  - Clustering
  - Binary search
- Lists
- Graphs
- Trees
- Communication
- Architectures
  - Among others

**Example:** Where to start cleaning the terrain?
- Distances
- Determine the most efficient route.
- Extrapolate to other scenarios.
- Etc...

# Algorithms

The computer is a great ally; it has a lot of energy, can work 24 hours, is efficient and fast. However, the computer doesn't operate by itself; it needs someone to provide detailed instructions, and we are the ones who do that. The main objective of the computer is to receive data, manipulate it, and store it. It performs these tasks through programs that provide instructions.

The problem-solving process occurs "step by step" using instructions. It is important to consider:

- What needs to be done?
- What is the order of execution?
- These instructions must be understood by both humans and machines/computers.

**Development of a program:**

- **Step 1: Analysis:** Study and definition of input and output data.
- **Step 2: Algorithm:** Describe the problem using narrative tools, flowcharts, or pseudocode.
- **Step 3: Coding:** The algorithm is coded according to the chosen programming language.

**An algorithm is a sequence of steps with a defined goal, performing specific tasks and a set of operations resulting in a finite succession of actions.**

**Examples of algorithms in daily life: Making a sandwich, changing a light bulb, following a cake recipe, commuting to work. All of these involve step-by-step instructions to complete the task.**

**How to build an algorithm:**

- Understanding the problem ("What are the most important points?").
- Defining input data (What data you will provide and what data you are working with, "provided data and scenario").
- Defining processing (What calculations and operations are required, and are there any constraints in this problem?).
- Defining output data (The data after processing).
- Using a construction method and conducting tests and diagnostics ("Constructing and refining the algorithm, optimizing it").

**Construction of algorithms:**

- **Narrative:** Using natural language, it is straightforward as it doesn't introduce any new concepts that you need to learn. The downside of this method is that there can be various different interpretations.

- **Flowchart:** Using predefined symbols, it is easy to understand but requires prior knowledge of the structure and symbols.

- **Pseudocode:** It has well-defined rules and leaves no room for misinterpretation, with a step-by-step process to follow.

**Example: Multiply two numbers.**

1. Receive the values
2. Multiply
3. Print (display on the screen) the result

**Example 2: Average of students**

1. Receive the values
2. Calculate the arithmetic average
3. Print the results
4. Pass/fail rule, for example, with an average of 6:
   - If the score is 6 or higher, print("Congratulations, you passed the year!")
   - If not, print("Unfortunately, you failed the year")
  
# Case Study

**Example 1:** You are lost in a forest. How to solve the problem using computational thinking?

- Identify mechanisms.
- Common resources.
- Most important details:
  - Survival = water, food, shelter.
  - Water: Rain, spring; after finding it, you need fire to boil it.
  - Food: Collecting, hunting; you need fire to cook it.
  - Shelter: Location, map; Protection, warm and dry. Spear, fire to stay dry and keep animals away.
- There is a pattern, the need for fire, which is the most important detail. The map doesn't need to be detailed, it can be abstract.

**Example 2:** Sum of a number between 1 and 200.

- Value repeats, how many times? 200/2 = 100.
- Result: 201 x 100 = 20,100.

**How to express this in a more generalized way?**

- Example: Sum of a number between x and y.
- [x, y] -> interval.
- y = 200, x = 1.
- y + x = partial result, 200 + 1 = 201.
- (y-1) + (x+1) = partial_result, 199 + 2 = 201.
- Total x Partial Result = result.
- y/2 = total, 200/2 = 100.
- Algorithm:
  1. Receive values (x and y).
  2. Solve: y/2 = total.
  3. Solve: y + x = partial result.
  4. Find the total.
  5. Final = total x partial result.
  6. Print the result.

**Example: Guess a number:**

- Is the number 1? No.
- Is the number 2? ... This way would take a long time.
- A more efficient way would be:
  - Is the number greater than 50? No.
  - Is the number less than 20? Yes.
  - We narrow down the range of possible numbers.

**Skill:**

- How to improve this skill?
  - Allowing your students to explain their decisions and their development process (Brennan & Resnick).
  - For a given problem.
  - "Take a problem and explain your decisions." 
